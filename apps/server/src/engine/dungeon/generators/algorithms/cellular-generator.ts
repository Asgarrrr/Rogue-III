/*
 * NOTE: This code is generated by AI for testing purposes only.
 * It's crap and needs to be completely rewritten.
 * Use only for initial testing.
 */

import { DungeonGenerator } from "../base/dungeon-generator";
import { DungeonConfig, DungeonSeed } from "../../core/types";
import { RoomImpl, ConnectionImpl, DungeonImpl } from "../../entities";

/**
 * Context passed between generation stages containing intermediate results.
 */
interface GenerationContext {
	grid?: boolean[][];
	caverns?: Array<Array<{ x: number; y: number }>>;
	rooms?: RoomImpl[];
	connections?: ConnectionImpl[];
}

/**
 * Represents a single stage in the dungeon generation pipeline.
 */
interface GenerationStage {
	name: string;
	weight: number; // Progress weight (0-100 total)
	execute: (
		context: GenerationContext
	) => Promise<GenerationContext | DungeonImpl>;
}

/**
 * Cellular Automata dungeon generator.
 *
 * This generator uses cellular automata rules to create natural-looking cave systems
 * and organic dungeon layouts. The algorithm simulates cellular growth patterns
 * to create interconnected cavern networks.
 *
 * The process involves:
 * 1. Random initialization of cells (wall/floor)
 * 2. Multiple iterations of cellular automata rules
 * 3. Cleanup and connection of resulting regions
 * 4. Room placement within the largest caverns
 *
 * @since 1.0.0
 * @example
 * ```typescript
 * const config = {
 *   width: 80,
 *   height: 60,
 *   roomCount: 8,
 *   roomSizeRange: [6, 15],
 *   algorithm: 'cellular'
 * };
 * const generator = new CellularGenerator(config, seeds);
 * const dungeon = generator.generate();
 * ```
 */
export class CellularGenerator extends DungeonGenerator {
	/** Probability of a cell being a wall during initialization */
	private readonly WALL_PROBABILITY = 0.4; // RÃ©duit pour plus d'espaces ouverts

	/** Number of cellular automata iterations */
	private readonly ITERATIONS = 2; // RÃ©duit pour optimisation - 2 itÃ©rations suffisent souvent

	/** Minimum neighbors required for a wall to survive */
	private readonly WALL_SURVIVAL_MIN = 4;

	/** Minimum neighbors required for a floor to become a wall */
	private readonly WALL_BIRTH_MIN = 5;

	/** Minimum cavern size to be considered valid */
	private readonly MIN_CAVERN_SIZE = 25; // RÃ©duit pour accepter plus de cavernes

	/** Maximum cavern size for room placement */
	private readonly MAX_ROOM_CAVERN_SIZE = 10000;

	/** Pre-computed directions for neighbor checks to avoid array creation */
	private readonly DIRECTIONS = [
		{ dx: -1, dy: -1 },
		{ dx: 0, dy: -1 },
		{ dx: 1, dy: -1 },
		{ dx: -1, dy: 0 },
		{ dx: 1, dy: 0 },
		{ dx: -1, dy: 1 },
		{ dx: 0, dy: 1 },
		{ dx: 1, dy: 1 },
	] as const;

	/**
	 * Creates a new cellular automata dungeon generator.
	 *
	 * @param config - Dungeon generation configuration
	 * @param seeds - Seed set for reproducible generation
	 */
	constructor(config: DungeonConfig, seeds: DungeonSeed) {
		super(config, seeds);
	}

	/**
	 * Generates a dungeon using cellular automata algorithm.
	 *
	 * @returns A fully generated dungeon with natural cave-like structures
	 */
	generate(): DungeonImpl {
		return this.generateSync();
	}

	/**
	 * Synchronous generation implementation (extracted for reuse).
	 *
	 * @returns A fully generated dungeon
	 * @private
	 */
	private generateSync(): DungeonImpl {
		console.log(
			`Generating cellular dungeon with seeds: L=${this.seeds.layout}, R=${this.seeds.rooms}`
		);

		// Phase 1: Generate cellular grid
		const grid = this.generateCellularGrid();
		console.log(
			`ðŸ” Grid generated: ${this.config.width}x${this.config.height}`
		);

		// Phase 2: Find and process caverns
		const caverns = this.findCaverns(grid);
		console.log(`ðŸ” Found ${caverns.length} caverns`);

		const validCaverns = this.filterValidCaverns(caverns);
		console.log(
			`ðŸ” Valid caverns: ${validCaverns.length} (min size: ${this.MIN_CAVERN_SIZE})`
		);

		validCaverns.forEach((cavern, i) => {
			console.log(`  Cavern ${i}: ${cavern.length} cells`);
		});

		// Phase 3: Create rooms from largest caverns
		const rooms = this.createRoomsFromCaverns(validCaverns, grid);
		console.log(`ðŸ” Created ${rooms.length} rooms from caverns`);

		// Phase 4: Create connections between rooms
		const connections = this.createConnections(rooms, grid);
		console.log(`ðŸ” Created ${connections.length} connections`);

		// Phase 5: Generate checksum
		const checksum = this.calculateChecksum(rooms, connections);

		return new DungeonImpl({
			rooms,
			connections,
			config: this.config,
			seeds: this.seeds,
			checksum,
		});
	}

	/**
	 * Generates a dungeon asynchronously with progress tracking and yielding.
	 * Perfect for UI responsiveness and large dungeon generation.
	 *
	 * @param onProgress - Optional callback for progress updates (0-100)
	 * @returns A promise that resolves to the generated dungeon
	 */
	async generateAsync(
		onProgress?: (progress: number) => void
	): Promise<DungeonImpl> {
		console.log(
			`ðŸ”„ Generating cellular dungeon asynchronously with seeds: L=${this.seeds.layout}, R=${this.seeds.rooms}`
		);

		// Define generation stages for modularity
		const stages = this.createGenerationStages();

		// Execute stages with progress tracking
		const result = await this.executeStages(stages, onProgress);

		console.log(`âœ… Dungeon generation completed asynchronously`);
		return result;
	}

	/**
	 * Creates the generation stages pipeline.
	 * Each stage is a modular step in the dungeon generation process.
	 *
	 * @returns Array of generation stages with their configurations
	 * @private
	 */
	private createGenerationStages(): GenerationStage[] {
		return [
			{
				name: "Generate cellular grid",
				weight: 25,
				execute: async () => {
					const grid = this.generateCellularGrid();
					console.log(
						`ðŸ” Grid generated: ${this.config.width}x${this.config.height}`
					);
					return { grid };
				},
			},
			{
				name: "Find and process caverns",
				weight: 25,
				execute: async (context: GenerationContext) => {
					const grid = context.grid!;
					const caverns = this.findCaverns(grid);
					console.log(`ðŸ” Found ${caverns.length} caverns`);

					const validCaverns = this.filterValidCaverns(caverns);
					console.log(
						`ðŸ” Valid caverns: ${validCaverns.length} (min size: ${this.MIN_CAVERN_SIZE})`
					);
					return { ...context, caverns: validCaverns };
				},
			},
			{
				name: "Create rooms from caverns",
				weight: 25,
				execute: async (context: GenerationContext) => {
					const grid = context.grid!;
					const validCaverns = context.caverns!;
					const rooms = this.createRoomsFromCaverns(validCaverns, grid);
					console.log(`ðŸ” Created ${rooms.length} rooms from caverns`);
					return { ...context, rooms };
				},
			},
			{
				name: "Create connections",
				weight: 15,
				execute: async (context: GenerationContext) => {
					const rooms = context.rooms!;
					const grid = context.grid!;
					const connections = this.createConnections(rooms, grid);
					console.log(`ðŸ” Created ${connections.length} connections`);
					return { ...context, connections };
				},
			},
			{
				name: "Finalize dungeon",
				weight: 10,
				execute: async (context: GenerationContext) => {
					const rooms = context.rooms!;
					const connections = context.connections!;
					const checksum = this.calculateChecksum(rooms, connections);

					const dungeon = new DungeonImpl({
						rooms,
						connections,
						config: this.config,
						seeds: this.seeds,
						checksum,
					});

					return dungeon;
				},
			},
		];
	}

	/**
	 * Executes the generation stages sequentially with progress tracking.
	 *
	 * @param stages - Array of generation stages to execute
	 * @param onProgress - Optional progress callback
	 * @returns Promise resolving to the final dungeon
	 * @private
	 */
	private async executeStages(
		stages: GenerationStage[],
		onProgress?: (progress: number) => void
	): Promise<DungeonImpl> {
		let currentProgress = 0;
		onProgress?.(currentProgress);

		let context: GenerationContext = {};

		for (const stage of stages) {
			// Execute the stage
			const result = await stage.execute(context);

			// Update context with stage result
			if (result instanceof DungeonImpl) {
				// Final stage - return the dungeon
				onProgress?.(100);
				return result;
			} else {
				// Intermediate stage - update context
				context = result as GenerationContext;
			}

			// Update progress
			currentProgress += stage.weight;
			onProgress?.(currentProgress);

			// Yield control to keep UI responsive
			await this.yield();
		}

		throw new Error("Generation pipeline did not complete with a dungeon");
	}

	/**
	 * Utility method to yield control back to the event loop.
	 * Allows UI to remain responsive during generation.
	 *
	 * @private
	 */
	private async yield(): Promise<void> {
		return new Promise((resolve) => setTimeout(resolve, 0));
	}

	/**
	 * Generates the initial cellular grid and applies automata rules.
	 *
	 * @returns A 2D grid representing the dungeon layout
	 * @private
	 */
	private generateCellularGrid(): boolean[][] {
		const { width, height } = this.config;
		let grid: boolean[][] = [];

		// Initialize grid with random walls/floors
		for (let y = 0; y < height; y++) {
			grid[y] = [];
			for (let x = 0; x < width; x++) {
				grid[y][x] = this.layoutRng.next() < this.WALL_PROBABILITY;
			}
		}

		// Apply cellular automata rules for multiple iterations
		for (let i = 0; i < this.ITERATIONS; i++) {
			grid = this.applyCellularRules(grid);
		}

		return grid;
	}

	/**
	 * Applies cellular automata rules to the entire grid.
	 * Optimized version using pre-computed neighbor counts for better performance.
	 *
	 * @param grid - Current grid state
	 * @returns New grid state after applying rules
	 * @private
	 */
	private applyCellularRules(grid: boolean[][]): boolean[][] {
		const { width, height } = this.config;
		const newGrid: boolean[][] = Array(height);

		// Pre-compute neighbor counts for better cache locality
		const neighborCounts: number[][] = Array(height);
		for (let y = 0; y < height; y++) {
			neighborCounts[y] = Array(width);
			for (let x = 0; x < width; x++) {
				neighborCounts[y][x] = this.countNeighborsOptimized(
					grid,
					x,
					y,
					width,
					height
				);
			}
		}

		// Apply rules using pre-computed counts
		for (let y = 0; y < height; y++) {
			newGrid[y] = Array(width);
			for (let x = 0; x < width; x++) {
				const neighbors = neighborCounts[y][x];
				const isWall = grid[y][x];

				if (isWall) {
					// Wall survives if it has enough neighbors
					newGrid[y][x] = neighbors >= this.WALL_SURVIVAL_MIN;
				} else {
					// Floor becomes wall if it has enough neighbors
					newGrid[y][x] = neighbors >= this.WALL_BIRTH_MIN;
				}
			}
		}

		return newGrid;
	}

	/**
	 * Counts the number of wall neighbors for a given cell.
	 * Optimized version using pre-computed directions.
	 *
	 * @param grid - The grid to analyze
	 * @param x - X coordinate of the cell
	 * @param y - Y coordinate of the cell
	 * @returns Number of wall neighbors (0-8)
	 * @private
	 */
	private countNeighbors(grid: boolean[][], x: number, y: number): number {
		const { width, height } = this.config;
		let count = 0;

		// Use pre-computed directions for better performance
		for (const dir of this.DIRECTIONS) {
			const nx = x + dir.dx;
			const ny = y + dir.dy;

			if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
				if (grid[ny][nx]) count++;
			} else {
				// Treat out-of-bounds as walls
				count++;
			}
		}

		return count;
	}

	/**
	 * Optimized neighbor counting with pre-computed directions.
	 * Uses cached direction array to avoid repeated calculations.
	 *
	 * @param grid - The grid to analyze
	 * @param x - X coordinate of the cell
	 * @param y - Y coordinate of the cell
	 * @param width - Grid width (pre-computed)
	 * @param height - Grid height (pre-computed)
	 * @returns Number of wall neighbors (0-8)
	 * @private
	 */
	private countNeighborsOptimized(
		grid: boolean[][],
		x: number,
		y: number,
		width: number,
		height: number
	): number {
		let count = 0;

		// Use pre-computed directions for better performance
		for (const dir of this.DIRECTIONS) {
			const nx = x + dir.dx;
			const ny = y + dir.dy;

			if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
				if (grid[ny][nx]) count++;
			} else {
				// Out of bounds counts as wall
				count++;
			}
		}

		return count;
	}

	/**
	 * Finds all connected cavern regions in the grid.
	 * Optimized version that skips processing obviously invalid areas.
	 *
	 * @param grid - The cellular grid
	 * @returns Array of cavern regions (each cavern is an array of coordinates)
	 * @private
	 */
	private findCaverns(
		grid: boolean[][]
	): Array<Array<{ x: number; y: number }>> {
		const { width, height } = this.config;
		const visited: boolean[][] = Array(height);
		for (let i = 0; i < height; i++) {
			visited[i] = Array(width).fill(false);
		}
		const caverns: Array<Array<{ x: number; y: number }>> = [];

		// Pre-compute wall density to skip dense areas
		const wallDensity = this.calculateWallDensity(grid);

		for (let y = 0; y < height; y++) {
			for (let x = 0; x < width; x++) {
				if (!grid[y][x] && !visited[y][x]) {
					// Skip if area has too many walls (optimization)
					if (wallDensity[y][x] > 0.7) continue;

					const cavern = this.floodFillCavernOptimized(
						grid,
						visited,
						x,
						y,
						width,
						height
					);
					if (cavern.length >= this.MIN_CAVERN_SIZE) {
						caverns.push(cavern);
					}
				}
			}
		}

		return caverns;
	}

	/**
	 * Calculates wall density in 3x3 neighborhoods to identify dense areas.
	 * Used for optimization to skip areas that are unlikely to contain valid caverns.
	 *
	 * @param grid - The cellular grid
	 * @returns 2D array of wall density values (0.0 to 1.0)
	 * @private
	 */
	private calculateWallDensity(grid: boolean[][]): number[][] {
		const { width, height } = this.config;
		const density: number[][] = Array(height);
		for (let i = 0; i < height; i++) {
			density[i] = Array(width).fill(0);
		}

		for (let y = 0; y < height; y++) {
			for (let x = 0; x < width; x++) {
				let walls = 0;
				let total = 0;

				// Count walls in 3x3 neighborhood
				for (let dy = -1; dy <= 1; dy++) {
					for (let dx = -1; dx <= 1; dx++) {
						const nx = x + dx;
						const ny = y + dy;
						if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
							total++;
							if (grid[ny][nx]) walls++;
						}
					}
				}

				density[y][x] = total > 0 ? walls / total : 1.0;
			}
		}

		return density;
	}

	/**
	 * Performs flood fill to find all connected floor cells in a cavern.
	 *
	 * @param grid - The cellular grid
	 * @param visited - Visited tracking grid
	 * @param startX - Starting X coordinate
	 * @param startY - Starting Y coordinate
	 * @returns Array of coordinates in this cavern
	 * @private
	 */
	private floodFillCavern(
		grid: boolean[][],
		visited: boolean[][],
		startX: number,
		startY: number
	): Array<{ x: number; y: number }> {
		const { width, height } = this.config;
		const cavern: Array<{ x: number; y: number }> = [];
		const stack = [{ x: startX, y: startY }];

		while (stack.length > 0) {
			const { x, y } = stack.pop()!;

			if (
				x < 0 ||
				x >= width ||
				y < 0 ||
				y >= height ||
				visited[y][x] ||
				grid[y][x]
			) {
				continue;
			}

			visited[y][x] = true;
			cavern.push({ x, y });

			// Add adjacent cells
			stack.push({ x: x + 1, y });
			stack.push({ x: x - 1, y });
			stack.push({ x, y: y + 1 });
			stack.push({ x, y: y - 1 });
		}

		return cavern;
	}

	/**
	 * Optimized flood fill using iterative approach with bounds checking.
	 * Faster for large caverns and avoids stack overflow.
	 *
	 * @param grid - The cellular grid
	 * @param visited - Visited tracking grid
	 * @param startX - Starting X coordinate
	 * @param startY - Starting Y coordinate
	 * @param width - Grid width (pre-computed)
	 * @param height - Grid height (pre-computed)
	 * @returns Array of coordinates in this cavern
	 * @private
	 */
	private floodFillCavernOptimized(
		grid: boolean[][],
		visited: boolean[][],
		startX: number,
		startY: number,
		width: number,
		height: number
	): Array<{ x: number; y: number }> {
		const cavern: Array<{ x: number; y: number }> = [];
		const queue = [{ x: startX, y: startY }];
		visited[startY][startX] = true;

		let queueIndex = 0;
		while (queueIndex < queue.length) {
			const { x, y } = queue[queueIndex++];

			cavern.push({ x, y });

			// Check all 4 adjacent cells
			const directions = [
				{ x: x + 1, y },
				{ x: x - 1, y },
				{ x, y: y + 1 },
				{ x, y: y - 1 },
			];

			for (const next of directions) {
				if (
					next.x >= 0 &&
					next.x < width &&
					next.y >= 0 &&
					next.y < height &&
					!visited[next.y][next.x] &&
					!grid[next.y][next.x]
				) {
					visited[next.y][next.x] = true;
					queue.push(next);
				}
			}
		}

		return cavern;
	}

	/**
	 * Filters caverns to keep only those large enough for rooms.
	 *
	 * @param caverns - All found caverns
	 * @returns Filtered array of valid caverns
	 * @private
	 */
	private filterValidCaverns(
		caverns: Array<Array<{ x: number; y: number }>>
	): Array<Array<{ x: number; y: number }>> {
		return caverns.filter((cavern) => cavern.length >= this.MIN_CAVERN_SIZE);
	}

	/**
	 * Creates rooms by placing them within the largest caverns.
	 * Attempts to place multiple rooms per cavern if the cavern is large enough.
	 *
	 * @param caverns - Valid caverns for room placement
	 * @param grid - The cellular grid
	 * @returns Array of created rooms
	 * @private
	 */
	private createRoomsFromCaverns(
		caverns: Array<Array<{ x: number; y: number }>>,
		grid: boolean[][]
	): RoomImpl[] {
		const rooms: RoomImpl[] = [];
		const sortedCaverns = caverns.sort((a, b) => b.length - a.length);

		// Filter caverns by size
		const validCaverns = sortedCaverns.filter(
			(cavern) => cavern.length <= this.MAX_ROOM_CAVERN_SIZE
		);

		let roomId = 0;

		// Try to place rooms in caverns until we reach the target count
		for (const cavern of validCaverns) {
			if (rooms.length >= this.config.roomCount) break;

			// Try to place multiple rooms in this cavern
			const cavernRooms = this.createMultipleRoomsInCavern(
				cavern,
				grid,
				roomId
			);
			rooms.push(...cavernRooms);
			roomId += cavernRooms.length;
		}

		return rooms;
	}

	/**
	 * Creates multiple rooms within a single cavern, avoiding overlaps.
	 * Optimized with spatial occupancy grid for fast overlap detection.
	 *
	 * @param cavern - The cavern coordinates
	 * @param grid - The cellular grid
	 * @param startRoomId - Starting ID for rooms in this cavern
	 * @returns Array of created rooms
	 * @private
	 */
	private createMultipleRoomsInCavern(
		cavern: Array<{ x: number; y: number }>,
		grid: boolean[][],
		startRoomId: number
	): RoomImpl[] {
		const rooms: RoomImpl[] = [];
		const maxRoomsPerCavern = Math.min(5, Math.floor(cavern.length / 200)); // Estimate based on cavern size

		// Create occupancy grid for fast overlap checks
		const occupancyGrid = this.createOccupancyGrid(cavern);

		for (let i = 0; i < maxRoomsPerCavern; i++) {
			const room = this.createRoomInCavernAvoidingOverlapOptimized(
				cavern,
				grid,
				startRoomId + i,
				rooms,
				occupancyGrid
			);
			if (room) {
				rooms.push(room);
				// Update occupancy grid with new room
				this.markRoomInOccupancyGrid(occupancyGrid, room);
			} else {
				// Stop trying if we can't place another room
				break;
			}
		}

		return rooms;
	}

	/**
	 * Creates a single room within a cavern, avoiding overlap with existing rooms.
	 *
	 * @param cavern - The cavern coordinates
	 * @param grid - The cellular grid
	 * @param roomId - Unique ID for the room
	 * @param existingRooms - Already placed rooms to avoid
	 * @returns Created room or null if placement failed
	 * @private
	 */
	private createRoomInCavernAvoidingOverlap(
		cavern: Array<{ x: number; y: number }>,
		grid: boolean[][],
		roomId: number,
		existingRooms: RoomImpl[]
	): RoomImpl | null {
		// Find bounds of the cavern
		let minX = Infinity,
			maxX = -Infinity;
		let minY = Infinity,
			maxY = -Infinity;

		cavern.forEach(({ x, y }) => {
			minX = Math.min(minX, x);
			maxX = Math.max(maxX, x);
			minY = Math.min(minY, y);
			maxY = Math.max(maxY, y);
		});

		const cavernWidth = maxX - minX;
		const cavernHeight = maxY - minY;

		// Try to place a room within the cavern bounds
		const maxAttempts = 20; // More attempts since we need to avoid overlaps
		for (let attempt = 0; attempt < maxAttempts; attempt++) {
			const roomWidth = this.roomsRng.range(
				this.config.roomSizeRange[0],
				Math.min(this.config.roomSizeRange[1], maxX - minX - 2)
			);
			const roomHeight = this.roomsRng.range(
				this.config.roomSizeRange[0],
				Math.min(this.config.roomSizeRange[1], maxY - minY - 2)
			);

			const roomX = this.roomsRng.range(minX + 1, maxX - roomWidth - 1);
			const roomY = this.roomsRng.range(minY + 1, maxY - roomHeight - 1);

			// Check if room fits within cavern and doesn't overlap with existing rooms
			if (
				this.isRoomInCavern(roomX, roomY, roomWidth, roomHeight, cavern) &&
				!this.roomOverlapsWithExisting(
					roomX,
					roomY,
					roomWidth,
					roomHeight,
					existingRooms
				)
			) {
				const roomType = this.roomsRng.choice([
					"normal",
					"treasure",
					"monster",
				]);
				return new RoomImpl({
					id: roomId,
					x: roomX,
					y: roomY,
					width: roomWidth,
					height: roomHeight,
					type: roomType,
					seed: this.roomsRng.range(0, 999999),
				});
			}
		}
		return null;
	}

	/**
	 * Optimized room creation with spatial occupancy grid for overlap detection.
	 *
	 * @param cavern - The cavern coordinates
	 * @param grid - The cellular grid
	 * @param roomId - Unique ID for the room
	 * @param existingRooms - Already placed rooms to avoid
	 * @param occupancyGrid - Spatial grid for fast overlap checks
	 * @returns Created room or null if placement failed
	 * @private
	 */
	private createRoomInCavernAvoidingOverlapOptimized(
		cavern: Array<{ x: number; y: number }>,
		grid: boolean[][],
		roomId: number,
		existingRooms: RoomImpl[],
		occupancyGrid: boolean[][]
	): RoomImpl | null {
		// Find bounds of the cavern
		let minX = Infinity,
			maxX = -Infinity;
		let minY = Infinity,
			maxY = -Infinity;

		cavern.forEach(({ x, y }) => {
			minX = Math.min(minX, x);
			maxX = Math.max(maxX, x);
			minY = Math.min(minY, y);
			maxY = Math.max(maxY, y);
		});

		const cavernWidth = maxX - minX;
		const cavernHeight = maxY - minY;

		// Try to place a room within the cavern bounds
		const maxAttempts = 20;
		for (let attempt = 0; attempt < maxAttempts; attempt++) {
			const roomWidth = this.roomsRng.range(
				this.config.roomSizeRange[0],
				Math.min(this.config.roomSizeRange[1], maxX - minX - 2)
			);
			const roomHeight = this.roomsRng.range(
				this.config.roomSizeRange[0],
				Math.min(this.config.roomSizeRange[1], maxY - minY - 2)
			);

			const roomX = this.roomsRng.range(minX + 1, maxX - roomWidth - 1);
			const roomY = this.roomsRng.range(minY + 1, maxY - roomHeight - 1);

			// Check if room fits within cavern and doesn't overlap with existing rooms
			if (
				this.isRoomInCavern(roomX, roomY, roomWidth, roomHeight, cavern) &&
				!this.roomOverlapsWithOccupancyGrid(
					roomX,
					roomY,
					roomWidth,
					roomHeight,
					occupancyGrid
				)
			) {
				const roomType = this.roomsRng.choice([
					"normal",
					"treasure",
					"monster",
				]);
				return new RoomImpl({
					id: roomId,
					x: roomX,
					y: roomY,
					width: roomWidth,
					height: roomHeight,
					type: roomType,
					seed: this.roomsRng.range(0, 999999),
				});
			}
		}
		return null;
	}

	/**
	 * Creates an occupancy grid for fast overlap detection.
	 *
	 * @param cavern - Cavern coordinates that define available space
	 * @returns 2D boolean grid where true indicates occupied space
	 * @private
	 */
	private createOccupancyGrid(
		cavern: Array<{ x: number; y: number }>
	): boolean[][] {
		const { width, height } = this.config;
		const grid: boolean[][] = Array(height);
		for (let i = 0; i < height; i++) {
			grid[i] = Array(width).fill(false);
		}
		return grid; // Initially all false (unoccupied)
	}

	/**
	 * Marks a room in the occupancy grid.
	 *
	 * @param occupancyGrid - The occupancy grid to update
	 * @param room - Room to mark as occupied
	 * @private
	 */
	private markRoomInOccupancyGrid(
		occupancyGrid: boolean[][],
		room: RoomImpl
	): void {
		for (let y = room.y; y < room.y + room.height; y++) {
			for (let x = room.x; x < room.x + room.width; x++) {
				if (
					y >= 0 &&
					y < occupancyGrid.length &&
					x >= 0 &&
					x < occupancyGrid[0].length
				) {
					occupancyGrid[y][x] = true;
				}
			}
		}
	}

	/**
	 * Fast overlap detection using spatial occupancy grid.
	 *
	 * @param x - Room X position
	 * @param y - Room Y position
	 * @param width - Room width
	 * @param height - Room height
	 * @param occupancyGrid - Spatial grid to check against
	 * @returns True if room overlaps with occupied space
	 * @private
	 */
	private roomOverlapsWithOccupancyGrid(
		x: number,
		y: number,
		width: number,
		height: number,
		occupancyGrid: boolean[][]
	): boolean {
		// Bounds check
		if (
			x < 0 ||
			y < 0 ||
			y + height > occupancyGrid.length ||
			x + width > occupancyGrid[0].length
		) {
			return true; // Out of bounds = overlap
		}

		for (let ry = y; ry < y + height; ry++) {
			for (let rx = x; rx < x + width; rx++) {
				if (occupancyGrid[ry][rx]) {
					return true; // Overlap detected
				}
			}
		}
		return false;
	}

	/**
	 * Checks if a room overlaps with any existing rooms.
	 *
	 * @param x - Room X position
	 * @param y - Room Y position
	 * @param width - Room width
	 * @param height - Room height
	 * @param existingRooms - Rooms to check against
	 * @returns True if room overlaps with any existing room
	 * @private
	 */
	private roomOverlapsWithExisting(
		x: number,
		y: number,
		width: number,
		height: number,
		existingRooms: RoomImpl[]
	): boolean {
		for (const existingRoom of existingRooms) {
			if (
				x < existingRoom.x + existingRoom.width &&
				x + width > existingRoom.x &&
				y < existingRoom.y + existingRoom.height &&
				y + height > existingRoom.y
			) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Creates a single room within a cavern.
	 *
	 * @param cavern - The cavern coordinates
	 * @param grid - The cellular grid
	 * @param roomId - Unique ID for the room
	 * @returns Created room or null if placement failed
	 * @private
	 */
	private createRoomInCavern(
		cavern: Array<{ x: number; y: number }>,
		grid: boolean[][],
		roomId: number
	): RoomImpl | null {
		// Find bounds of the cavern
		let minX = Infinity,
			maxX = -Infinity;
		let minY = Infinity,
			maxY = -Infinity;

		cavern.forEach(({ x, y }) => {
			minX = Math.min(minX, x);
			maxX = Math.max(maxX, x);
			minY = Math.min(minY, y);
			maxY = Math.max(maxY, y);
		});

		const cavernWidth = maxX - minX;
		const cavernHeight = maxY - minY;

		// Try to place a room within the cavern bounds
		const maxAttempts = 10;
		for (let attempt = 0; attempt < maxAttempts; attempt++) {
			const roomWidth = this.roomsRng.range(
				this.config.roomSizeRange[0],
				Math.min(this.config.roomSizeRange[1], maxX - minX - 2)
			);
			const roomHeight = this.roomsRng.range(
				this.config.roomSizeRange[0],
				Math.min(this.config.roomSizeRange[1], maxY - minY - 2)
			);

			const roomX = this.roomsRng.range(minX + 1, maxX - roomWidth - 1);
			const roomY = this.roomsRng.range(minY + 1, maxY - roomHeight - 1);

			// Check if room fits within cavern
			if (this.isRoomInCavern(roomX, roomY, roomWidth, roomHeight, cavern)) {
				const roomType = this.roomsRng.choice([
					"normal",
					"treasure",
					"monster",
				]);
				return new RoomImpl({
					id: roomId,
					x: roomX,
					y: roomY,
					width: roomWidth,
					height: roomHeight,
					type: roomType,
					seed: this.roomsRng.range(0, 999999),
				});
			}
		}
		return null;
	}

	/**
	 * Checks if a room placement is sufficiently within a cavern.
	 * Uses a percentage-based approach to allow for irregular cavern shapes.
	 * Optimized version using spatial grid instead of Set lookups.
	 *
	 * @param x - Room X position
	 * @param y - Room Y position
	 * @param width - Room width
	 * @param height - Room height
	 * @param cavern - Cavern coordinates
	 * @returns True if room fits within cavern (at least 70% coverage)
	 * @private
	 */
	private isRoomInCavern(
		x: number,
		y: number,
		width: number,
		height: number,
		cavern: Array<{ x: number; y: number }>
	): boolean {
		// Create a spatial grid for fast lookups
		const cavernGrid = this.createCavernGrid(cavern);
		const totalCells = width * height;
		let validCells = 0;

		// Early exit for out-of-bounds rooms
		if (
			x < 0 ||
			y < 0 ||
			x + width > cavernGrid[0].length ||
			y + height > cavernGrid.length
		) {
			return false;
		}

		for (let ry = y; ry < y + height; ry++) {
			for (let rx = x; rx < x + width; rx++) {
				if (cavernGrid[ry] && cavernGrid[ry][rx]) {
					validCells++;
				}
			}
		}

		const coverageRatio = validCells / totalCells;
		return coverageRatio >= 0.7; // At least 70% of the room must be in the cavern
	}

	/**
	 * Creates a spatial grid from cavern coordinates for fast lookups.
	 *
	 * @param cavern - Cavern coordinates
	 * @returns 2D boolean grid where true indicates cavern floor
	 * @private
	 */
	private createCavernGrid(
		cavern: Array<{ x: number; y: number }>
	): boolean[][] {
		const { width, height } = this.config;
		const grid: boolean[][] = Array(height);
		for (let i = 0; i < height; i++) {
			grid[i] = Array(width).fill(false);
		}

		// Mark cavern cells
		for (const cell of cavern) {
			if (cell.x >= 0 && cell.x < width && cell.y >= 0 && cell.y < height) {
				grid[cell.y][cell.x] = true;
			}
		}

		return grid;
	}

	/**
	 * Creates connections between rooms using the cellular grid.
	 *
	 * @param rooms - Array of rooms to connect
	 * @param grid - The cellular grid
	 * @returns Array of created connections
	 * @private
	 */
	private createConnections(
		rooms: RoomImpl[],
		grid: boolean[][]
	): ConnectionImpl[] {
		const connections: ConnectionImpl[] = [];

		// Simple connection strategy: connect each room to the next
		for (let i = 0; i < rooms.length - 1; i++) {
			const room1 = rooms[i];
			const room2 = rooms[i + 1];

			const path = this.findPath(room1, room2, grid);
			if (path.length > 0) {
				connections.push(new ConnectionImpl(room1, room2, path, "cellular"));
			}
		}

		return connections;
	}

	/**
	 * Finds a path between two rooms using optimized A* pathfinding.
	 *
	 * @param room1 - Starting room
	 * @param room2 - Target room
	 * @param grid - The cellular grid
	 * @returns Array of path coordinates
	 * @private
	 */
	private findPath(
		room1: RoomImpl,
		room2: RoomImpl,
		grid: boolean[][]
	): Array<{ x: number; y: number }> {
		const startX = room1.centerX;
		const startY = room1.centerY;
		const endX = room2.centerX;
		const endY = room2.centerY;

		// Try direct path first (fast check)
		if (this.isDirectPathClear(startX, startY, endX, endY, grid)) {
			return this.createDirectPath(startX, startY, endX, endY);
		}

		// Fall back to A* pathfinding
		return this.findPathAStar(startX, startY, endX, endY, grid);
	}

	/**
	 * Fast check if direct path is clear of walls.
	 *
	 * @param startX - Starting X coordinate
	 * @param startY - Starting Y coordinate
	 * @param endX - Ending X coordinate
	 * @param endY - Ending Y coordinate
	 * @param grid - The cellular grid
	 * @returns True if direct path is clear
	 * @private
	 */
	private isDirectPathClear(
		startX: number,
		startY: number,
		endX: number,
		endY: number,
		grid: boolean[][]
	): boolean {
		const steps = Math.max(Math.abs(endX - startX), Math.abs(endY - startY));

		for (let i = 0; i <= steps; i++) {
			const t = i / steps;
			const x = Math.round(startX + (endX - startX) * t);
			const y = Math.round(startY + (endY - startY) * t);

			if (grid[y] && grid[y][x]) {
				return false; // Hit a wall
			}
		}

		return true;
	}

	/**
	 * Creates a direct linear path between two points.
	 *
	 * @param startX - Starting X coordinate
	 * @param startY - Starting Y coordinate
	 * @param endX - Ending X coordinate
	 * @param endY - Ending Y coordinate
	 * @returns Array of path coordinates
	 * @private
	 */
	private createDirectPath(
		startX: number,
		startY: number,
		endX: number,
		endY: number
	): Array<{ x: number; y: number }> {
		const path: Array<{ x: number; y: number }> = [];
		const steps = Math.max(Math.abs(endX - startX), Math.abs(endY - startY));

		for (let i = 0; i <= steps; i++) {
			const t = i / steps;
			const x = Math.round(startX + (endX - startX) * t);
			const y = Math.round(startY + (endY - startY) * t);
			path.push({ x, y });
		}

		return path;
	}

	/**
	 * Optimized A* pathfinding implementation.
	 *
	 * @param startX - Starting X coordinate
	 * @param startY - Starting Y coordinate
	 * @param endX - Ending X coordinate
	 * @param endY - Ending Y coordinate
	 * @param grid - The cellular grid
	 * @returns Array of path coordinates
	 * @private
	 */
	private findPathAStar(
		startX: number,
		startY: number,
		endX: number,
		endY: number,
		grid: boolean[][]
	): Array<{ x: number; y: number }> {
		const { width, height } = this.config;

		// A* node structure
		interface Node {
			x: number;
			y: number;
			g: number; // Cost from start
			h: number; // Heuristic to end
			f: number; // Total cost
			parent: Node | null;
		}

		// Helper functions
		const createNode = (
			x: number,
			y: number,
			parent: Node | null = null
		): Node => {
			const g = parent ? parent.g + 1 : 0;
			const h = Math.abs(x - endX) + Math.abs(y - endY); // Manhattan distance
			return { x, y, g, h, f: g + h, parent };
		};

		const getKey = (x: number, y: number) => `${x},${y}`;

		// A* algorithm
		const openSet = new Map<string, Node>();
		const closedSet = new Set<string>();
		const startNode = createNode(startX, startY);
		openSet.set(getKey(startX, startY), startNode);

		while (openSet.size > 0) {
			// Find node with lowest f score
			let current: Node | undefined;
			let lowestF = Infinity;

			for (const node of openSet.values()) {
				if (node.f < lowestF) {
					lowestF = node.f;
					current = node;
				}
			}

			if (!current) break;

			// Check if we reached the end
			if (current.x === endX && current.y === endY) {
				// Reconstruct path
				const path: Array<{ x: number; y: number }> = [];
				let node: Node | null = current;
				while (node) {
					path.unshift({ x: node.x, y: node.y });
					node = node.parent;
				}
				return path;
			}

			// Move current to closed set
			const currentKey = getKey(current.x, current.y);
			openSet.delete(currentKey);
			closedSet.add(currentKey);

			// Check neighbors
			const neighbors = [
				{ x: current.x + 1, y: current.y },
				{ x: current.x - 1, y: current.y },
				{ x: current.x, y: current.y + 1 },
				{ x: current.x, y: current.y - 1 },
			];

			for (const neighbor of neighbors) {
				const { x, y } = neighbor;

				// Bounds and wall check
				if (
					x < 0 ||
					x >= width ||
					y < 0 ||
					y >= height ||
					grid[y][x] || // Wall check
					closedSet.has(getKey(x, y))
				) {
					continue;
				}

				const neighborKey = getKey(x, y);
				const existingNode = openSet.get(neighborKey);

				if (!existingNode) {
					openSet.set(neighborKey, createNode(x, y, current));
				} else if (current.g + 1 < existingNode.g) {
					// Better path found
					existingNode.g = current.g + 1;
					existingNode.f = existingNode.g + existingNode.h;
					existingNode.parent = current;
				}
			}
		}

		// No path found, return direct path as fallback
		return this.createDirectPath(startX, startY, endX, endY);
	}

	/**
	 * Calculates a checksum for the generated dungeon using incremental hashing.
	 *
	 * @param rooms - Generated rooms
	 * @param connections - Generated connections
	 * @returns Checksum string
	 * @private
	 */
	private calculateChecksum(
		rooms: RoomImpl[],
		connections: ConnectionImpl[]
	): string {
		// Use incremental hashing for better performance
		let hash = 5381; // djb2 initial value

		// Hash rooms
		for (const room of rooms) {
			const roomData = `${room.x},${room.y},${room.width},${room.height},${room.type}`;
			hash = this.updateHash(hash, roomData);
		}

		// Hash connections
		for (const connection of connections) {
			const connectionData = `${connection.from.id}-${connection.to.id}`;
			hash = this.updateHash(hash, connectionData);
		}

		return Math.abs(hash >>> 0).toString(36);
	}

	/**
	 * Updates hash incrementally with new data.
	 *
	 * @param currentHash - Current hash value
	 * @param data - Data to add to hash
	 * @returns Updated hash value
	 * @private
	 */
	private updateHash(currentHash: number, data: string): number {
		let hash = currentHash;
		for (let i = 0; i < data.length; i++) {
			const char = data.charCodeAt(i);
			hash = (hash * 33) ^ char; // djb2 algorithm
		}
		return hash;
	}
}

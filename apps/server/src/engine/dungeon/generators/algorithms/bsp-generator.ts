/*
 * NOTE: This code is generated by AI for testing purposes only.
 * It's crap and needs to be completely rewritten.
 * Use only for initial testing.
 */

import { CellType, Grid } from "../../core/grid";
import type { DungeonConfig, DungeonSeed } from "../../core/types";
import {
  type ConnectionImpl,
  DungeonImpl,
  type RoomImpl,
} from "../../entities";
import {
  type GenContext,
  type Pipeline,
  PipelineRunner,
  type PipelineStep,
} from "../../generators/pipeline";
import { DungeonGenerator } from "../base/dungeon-generator";

/**
 * BSP (Binary Space Partitioning) Dungeon Generator
 *
 * Uses recursive space partitioning to create structured dungeon layouts.
 * Perfect for creating rooms with clear corridors and hierarchical spaces.
 *
 * Algorithm:
 * 1. Start with root space
 * 2. Recursively split spaces horizontally/vertically
 * 3. Create rooms in leaf spaces
 * 4. Connect rooms with corridors
 */
export class BSPGenerator extends DungeonGenerator {
  private readonly MIN_ROOM_SIZE = 8;
  private readonly MAX_SPLIT_RATIO = 0.6;
  private readonly MIN_SPLIT_RATIO = 0.4;

  constructor(config: DungeonConfig, seeds: DungeonSeed) {
    super(config, seeds);
  }

  generate(): DungeonImpl {
    console.log(
      `ðŸŒ³ Generating BSP dungeon with seeds: L=${this.seeds.layout}, R=${this.seeds.rooms}`,
    );

    const { grid, rooms, connections } = this.runPipeline();

    const checksum = this.calculateChecksum(rooms, connections);
    return new DungeonImpl({
      rooms,
      connections,
      config: this.config,
      seeds: this.seeds,
      checksum,
      grid: grid.toBooleanGrid(),
    });
  }

  private runPipeline(): {
    grid: Grid;
    rooms: RoomImpl[];
    connections: ConnectionImpl[];
  } {
    const steps: PipelineStep[] = [];
    const grid = new Grid(
      { width: this.config.width, height: this.config.height },
      CellType.WALL,
    );
    let rooms: RoomImpl[] = [];
    let connections: ConnectionImpl[] = [];

    // Initialize grid walls
    steps.push({
      id: "bsp.grid",
      io: { reads: [], writes: ["grid.base"] },
      run: (ctx) => {
        ctx.grid.base = grid;
      },
    });

    // Partition and place rooms
    steps.push({
      id: "bsp.rooms",
      io: { reads: ["grid.base"], writes: ["graphs.rooms"] },
      dependsOn: ["bsp.grid"],
      run: (ctx) => {
        const rootSpace = {
          x: 0,
          y: 0,
          width: this.config.width,
          height: this.config.height,
        };
        const spaces = this.generateSpaces(rootSpace);
        rooms = this.createRoomsFromSpaces(spaces) as unknown as RoomImpl[];
        ctx.graphs.rooms = rooms;
      },
    });

    // Connect rooms (simple paths)
    steps.push({
      id: "bsp.paths",
      io: { reads: ["graphs.rooms"], writes: ["graphs.connections"] },
      dependsOn: ["bsp.rooms"],
      run: (ctx) => {
        connections = this.generateConnections(
          rooms,
        ) as unknown as ConnectionImpl[];
        ctx.graphs.connections = connections;
      },
    });

    // Compose onto grid
    steps.push({
      id: "bsp.compose",
      io: {
        reads: ["grid.base", "graphs.rooms", "graphs.connections"],
        writes: ["grid.base"],
      },
      dependsOn: ["bsp.paths"],
      run: (ctx) => {
        // carve rooms
        for (const r of rooms) {
          grid.fillRect(r.x, r.y, r.width, r.height, CellType.FLOOR);
        }
        // carve simple corridor cells
        for (const c of connections) {
          for (const p of c.path) {
            const x = Math.floor(p.x),
              y = Math.floor(p.y);
            if (grid.isInBounds(x, y)) grid.setCell(x, y, CellType.FLOOR);
          }
        }
        ctx.grid.base = grid;
      },
    });

    const pipeline: Pipeline = { steps };
    const ctx: GenContext = {
      grid: { base: grid, layers: new Map() },
      graphs: { rooms: [], connections: [], regions: [] },
      config: this.config,
      meta: new Map(),
    };
    const runner = new PipelineRunner(pipeline);
    runner.runSync(ctx);
    return { grid, rooms, connections };
  }

  private generateSpaces(
    space: { x: number; y: number; width: number; height: number },
    depth = 0,
  ): Array<{ x: number; y: number; width: number; height: number }> {
    const maxDepth =
      Math.log2(Math.max(this.config.width, this.config.height)) - 2;

    // Stop recursion if space is too small or depth too deep
    if (
      space.width < this.MIN_ROOM_SIZE * 2 ||
      space.height < this.MIN_ROOM_SIZE * 2 ||
      depth > maxDepth
    ) {
      return [space];
    }

    // Decide split orientation
    const splitHorizontal = this.layoutRng.next() > 0.5;
    const spaces: Array<{
      x: number;
      y: number;
      width: number;
      height: number;
    }> = [];

    if (splitHorizontal) {
      const splitRatio = this.layoutRng.range(
        this.MIN_SPLIT_RATIO,
        this.MAX_SPLIT_RATIO,
      );
      const splitY = Math.floor(space.y + space.height * splitRatio);

      spaces.push(
        {
          x: space.x,
          y: space.y,
          width: space.width,
          height: splitY - space.y,
        },
        {
          x: space.x,
          y: splitY,
          width: space.width,
          height: space.height - (splitY - space.y),
        },
      );
    } else {
      const splitRatio = this.layoutRng.range(
        this.MIN_SPLIT_RATIO,
        this.MAX_SPLIT_RATIO,
      );
      const splitX = Math.floor(space.x + space.width * splitRatio);

      spaces.push(
        {
          x: space.x,
          y: space.y,
          width: splitX - space.x,
          height: space.height,
        },
        {
          x: splitX,
          y: space.y,
          width: space.width - (splitX - space.x),
          height: space.height,
        },
      );
    }

    // Recursively split child spaces
    const result: Array<{
      x: number;
      y: number;
      width: number;
      height: number;
    }> = [];
    for (const childSpace of spaces) {
      result.push(...this.generateSpaces(childSpace, depth + 1));
    }

    return result;
  }

  private createRoomsFromSpaces(
    spaces: Array<{ x: number; y: number; width: number; height: number }>,
  ): RoomImpl[] {
    return spaces.map((space, index) => {
      // Create room smaller than space for corridors
      const margin = 2;
      const roomWidth = Math.max(
        this.MIN_ROOM_SIZE,
        space.width - margin * 2 - this.roomsRng.range(0, space.width * 0.3),
      );
      const roomHeight = Math.max(
        this.MIN_ROOM_SIZE,
        space.height - margin * 2 - this.roomsRng.range(0, space.height * 0.3),
      );

      const roomX =
        space.x +
        margin +
        this.roomsRng.range(0, space.width - roomWidth - margin * 2);
      const roomY =
        space.y +
        margin +
        this.roomsRng.range(0, space.height - roomHeight - margin * 2);

      const roomType = this.roomsRng.choice(["normal", "treasure", "monster"]);

      return {
        id: index,
        x: roomX,
        y: roomY,
        width: roomWidth,
        height: roomHeight,
        type: roomType,
        seed: this.roomsRng.range(0, 999999),
        get centerX() {
          return roomX + Math.floor(roomWidth / 2);
        },
        get centerY() {
          return roomY + Math.floor(roomHeight / 2);
        },
      } as unknown as RoomImpl;
    });
  }

  private generateConnections(rooms: RoomImpl[]): ConnectionImpl[] {
    const connections: ConnectionImpl[] = [] as unknown as ConnectionImpl[];

    // Simple connection strategy: connect each room to the next
    for (let i = 0; i < rooms.length - 1; i++) {
      const room1 = rooms[i];
      const room2 = rooms[i + 1];

      connections.push({
        from: room1,
        to: room2,
        path: this.createSimplePath(room1, room2),
        style: "straight",
      } as unknown as ConnectionImpl);
    }

    return connections;
  }

  private createSimplePath(
    room1: RoomImpl,
    room2: RoomImpl,
  ): Array<{ x: number; y: number }> {
    const path: Array<{ x: number; y: number }> = [];
    const steps = Math.max(
      Math.abs(room2.centerX - room1.centerX),
      Math.abs(room2.centerY - room1.centerY),
    );

    for (let i = 0; i <= steps; i++) {
      const t = steps > 0 ? i / steps : 0;
      const x = Math.round(room1.centerX + (room2.centerX - room1.centerX) * t);
      const y = Math.round(room1.centerY + (room2.centerY - room1.centerY) * t);
      path.push({ x, y });
    }

    return path;
  }

  private calculateChecksum(
    rooms: RoomImpl[],
    connections: ConnectionImpl[],
  ): string {
    const data = [
      ...rooms.map((r) => `${r.x},${r.y},${r.width},${r.height},${r.type}`),
      ...connections.map((c) => `${c.from.id}-${c.to.id}`),
    ].join("|");

    let hash = 5381;
    for (let i = 0; i < data.length; i++) {
      const char = data.charCodeAt(i);
      hash = (hash << 5) + hash + char;
      hash = hash >>> 0;
    }

    return Math.abs(hash >>> 0).toString(36);
  }
}

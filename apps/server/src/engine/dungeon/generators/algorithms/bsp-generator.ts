/*
 * NOTE: This code is generated by AI for testing purposes only.
 * It's crap and needs to be completely rewritten.
 * Use only for initial testing.
 */

import { DungeonGenerator } from "../base/dungeon-generator";
import { DungeonConfig, DungeonSeed } from "../../core/types";
import { DungeonImpl } from "../../entities";

/**
 * BSP (Binary Space Partitioning) Dungeon Generator
 *
 * Uses recursive space partitioning to create structured dungeon layouts.
 * Perfect for creating rooms with clear corridors and hierarchical spaces.
 *
 * Algorithm:
 * 1. Start with root space
 * 2. Recursively split spaces horizontally/vertically
 * 3. Create rooms in leaf spaces
 * 4. Connect rooms with corridors
 */
export class BSPGenerator extends DungeonGenerator {
	private readonly MIN_ROOM_SIZE = 8;
	private readonly MAX_SPLIT_RATIO = 0.6;
	private readonly MIN_SPLIT_RATIO = 0.4;

	constructor(config: DungeonConfig, seeds: DungeonSeed) {
		super(config, seeds);
	}

	generate(): DungeonImpl {
		console.log(
			`ðŸŒ³ Generating BSP dungeon with seeds: L=${this.seeds.layout}, R=${this.seeds.rooms}`
		);

		// Create root space
		const rootSpace = {
			x: 0,
			y: 0,
			width: this.config.width,
			height: this.config.height,
		};

		// Generate BSP tree
		const spaces = this.generateSpaces(rootSpace);

		// Create rooms from spaces
		const rooms = this.createRoomsFromSpaces(spaces);

		// Generate connections
		const connections = this.generateConnections(rooms);

		// Create checksum
		const checksum = this.calculateChecksum(rooms, connections);

		return new DungeonImpl({
			rooms,
			connections,
			config: this.config,
			seeds: this.seeds,
			checksum,
		});
	}

	private generateSpaces(space: any, depth = 0): any[] {
		const maxDepth =
			Math.log2(Math.max(this.config.width, this.config.height)) - 2;

		// Stop recursion if space is too small or depth too deep
		if (
			space.width < this.MIN_ROOM_SIZE * 2 ||
			space.height < this.MIN_ROOM_SIZE * 2 ||
			depth > maxDepth
		) {
			return [space];
		}

		// Decide split orientation
		const splitHorizontal = this.layoutRng.next() > 0.5;
		const spaces = [];

		if (splitHorizontal) {
			const splitRatio = this.layoutRng.range(
				this.MIN_SPLIT_RATIO,
				this.MAX_SPLIT_RATIO
			);
			const splitY = Math.floor(space.y + space.height * splitRatio);

			spaces.push(
				{
					x: space.x,
					y: space.y,
					width: space.width,
					height: splitY - space.y,
				},
				{
					x: space.x,
					y: splitY,
					width: space.width,
					height: space.height - (splitY - space.y),
				}
			);
		} else {
			const splitRatio = this.layoutRng.range(
				this.MIN_SPLIT_RATIO,
				this.MAX_SPLIT_RATIO
			);
			const splitX = Math.floor(space.x + space.width * splitRatio);

			spaces.push(
				{
					x: space.x,
					y: space.y,
					width: splitX - space.x,
					height: space.height,
				},
				{
					x: splitX,
					y: space.y,
					width: space.width - (splitX - space.x),
					height: space.height,
				}
			);
		}

		// Recursively split child spaces
		const result = [];
		for (const childSpace of spaces) {
			result.push(...this.generateSpaces(childSpace, depth + 1));
		}

		return result;
	}

	private createRoomsFromSpaces(spaces: any[]): any[] {
		return spaces.map((space, index) => {
			// Create room smaller than space for corridors
			const margin = 2;
			const roomWidth = Math.max(
				this.MIN_ROOM_SIZE,
				space.width - margin * 2 - this.roomsRng.range(0, space.width * 0.3)
			);
			const roomHeight = Math.max(
				this.MIN_ROOM_SIZE,
				space.height - margin * 2 - this.roomsRng.range(0, space.height * 0.3)
			);

			const roomX =
				space.x +
				margin +
				this.roomsRng.range(0, space.width - roomWidth - margin * 2);
			const roomY =
				space.y +
				margin +
				this.roomsRng.range(0, space.height - roomHeight - margin * 2);

			const roomType = this.roomsRng.choice(["normal", "treasure", "monster"]);

			return {
				id: index,
				x: roomX,
				y: roomY,
				width: roomWidth,
				height: roomHeight,
				type: roomType,
				seed: this.roomsRng.range(0, 999999),
				centerX: roomX + Math.floor(roomWidth / 2),
				centerY: roomY + Math.floor(roomHeight / 2),
			};
		});
	}

	private generateConnections(rooms: any[]): any[] {
		const connections = [];

		// Simple connection strategy: connect each room to the next
		for (let i = 0; i < rooms.length - 1; i++) {
			const room1 = rooms[i];
			const room2 = rooms[i + 1];

			connections.push({
				from: room1,
				to: room2,
				path: this.createSimplePath(room1, room2),
			});
		}

		return connections;
	}

	private createSimplePath(room1: any, room2: any): any[] {
		const path = [];
		const steps = Math.max(
			Math.abs(room2.centerX - room1.centerX),
			Math.abs(room2.centerY - room1.centerY)
		);

		for (let i = 0; i <= steps; i++) {
			const t = steps > 0 ? i / steps : 0;
			const x = Math.round(room1.centerX + (room2.centerX - room1.centerX) * t);
			const y = Math.round(room1.centerY + (room2.centerY - room1.centerY) * t);
			path.push({ x, y });
		}

		return path;
	}

	private calculateChecksum(rooms: any[], connections: any[]): string {
		const data = [
			...rooms.map((r) => `${r.x},${r.y},${r.width},${r.height},${r.type}`),
			...connections.map((c) => `${c.from.id}-${c.to.id}`),
		].join("|");

		let hash = 5381;
		for (let i = 0; i < data.length; i++) {
			const char = data.charCodeAt(i);
			hash = (hash << 5) + hash + char;
			hash = hash >>> 0;
		}

		return Math.abs(hash >>> 0).toString(36);
	}
}
